---
phase: 01-enable-list-drag-and-drop
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - frontend/src/pages/BoardPage.jsx
autonomous: false

must_haves:
  truths:
    - "Grabbing a list header and dragging left/right moves the column in real time with a drag ghost"
    - "Dropping a list in a new position and refreshing the page shows the same order"
    - "The UI updates immediately after drop — no spinner, no flash"
    - "If the API call fails the board reverts to the pre-drag column order"
    - "Card drag-and-drop still works across and within lists without regression"
    - "The Add List button/form is visible but disabled while a list drag is in progress"
  artifacts:
    - path: "frontend/src/pages/BoardPage.jsx"
      provides: "Full list drag-and-drop wiring"
      exports: ["BoardPage (default)"]
      contains: "type=\"LIST\""
  key_links:
    - from: "BoardPage DragDropContext"
      to: "outer Droppable type=LIST"
      via: "children render prop"
      pattern: "droppableId=\"board\""
    - from: "handleDragEnd LIST branch"
      to: "useMoveList mutate"
      via: "rebalanced positions array"
      pattern: "moveList"
    - from: "handleDragStart"
      to: "setIsDraggingList"
      via: "result.type === 'LIST'"
      pattern: "isDraggingList"
---

<objective>
Wire horizontal list drag-and-drop in BoardPage.jsx — the final step that makes
list reordering functional end-to-end.

Purpose: Plans 01 and 02 fixed the API layer and prepared the components. This plan
adds the outer board-level Droppable, wraps each ListColumn in a Draggable, handles
the LIST branch in onDragEnd (with optimistic rebalanced positions), and tracks drag
state to disable AddListForm during a drag.

Output:
  - frontend/src/pages/BoardPage.jsx fully wired for list and card DnD
</objective>

<execution_context>
../.github/skills/execute-plan/SKILL.md
@.gsd/templates/summary.md
</execution_context>

<context>
@.gsd/PROJECT.md
@.gsd/ROADMAP.md
@.gsd/phases/01-enable-list-drag-and-drop/01-01-SUMMARY.md
@.gsd/phases/01-enable-list-drag-and-drop/01-02-SUMMARY.md
@frontend/src/pages/BoardPage.jsx
@frontend/src/components/ListColumn.jsx
@frontend/src/components/AddListForm.jsx
@frontend/src/hooks/useBoardDetail.js
</context>

<tasks>

<task type="auto">
  <name>Task 1 — Wire BoardPage.jsx for list drag-and-drop</name>
  <files>frontend/src/pages/BoardPage.jsx</files>
  <action>
    Make the following changes to BoardPage.jsx in order:

    ── 1. Update imports ───────────────────────────────────────────────────────

    a) Add `Draggable` and `Droppable` to the @hello-pangea/dnd import:
         import { DragDropContext, Draggable, Droppable } from '@hello-pangea/dnd';

    b) Add `useState` to the React import (if not already imported — check first):
         import { useState } from 'react';

    c) Add `useMoveList` to the useBoardDetail import:
         import { useBoardDetail, useMoveCard, useMoveList, useDeleteList } from '../hooks/useBoardDetail';

    ── 2. Add drag state + useMoveList ─────────────────────────────────────────

    After the existing `const { mutate: moveCard } = useMoveCard(boardId);` line, add:

      const { mutate: moveList } = useMoveList(boardId);
      const [isDraggingList, setIsDraggingList] = useState(false);

    ── 3. Add handleDragStart ───────────────────────────────────────────────────

    Add a new handler immediately before handleDragEnd:

      const handleDragStart = (result) => {
        if (result.type === 'LIST') {
          setIsDraggingList(true);
        }
      };

    ── 4. Add LIST branch to handleDragEnd ─────────────────────────────────────

    At the TOP of handleDragEnd, before any existing guard clauses, add the LIST
    handler and reset drag state. Replace the entire handleDragEnd function body
    with the following updated version:

      const handleDragEnd = (result) => {
        // Always clear drag state on drop
        setIsDraggingList(false);

        const { draggableId, type, source, destination } = result;

        // No destination: dropped outside a droppable → ignore
        if (!destination) return;

        // Dropped back in the same spot → ignore
        if (
          source.droppableId === destination.droppableId &&
          source.index === destination.index
        ) {
          return;
        }

        if (!board) return;

        // ── LIST drag ──────────────────────────────────────────────────────────
        if (type === 'LIST') {
          // Build the new ordered array by moving the dragged list from source.index
          // to destination.index
          const reordered = [...sortedLists];
          const [moved] = reordered.splice(source.index, 1);
          reordered.splice(destination.index, 0, moved);

          // Assign clean positions (1000, 2000, 3000…) so server and cache agree
          // after the subsequent invalidation refetch — no flicker from float drift
          const lists = reordered.map((l, i) => ({
            ...l,
            position: (i + 1) * 1000,
          }));

          moveList({ lists });
          return;
        }

        // ── CARD drag ─────────────────────────────────────────────────────────
        const destList = board.lists.find((l) => l.id === destination.droppableId);
        if (!destList) return;

        const destCards = [...(destList.cards ?? [])].sort(
          (a, b) => a.position - b.position
        );

        const isSameList = source.droppableId === destination.droppableId;
        const filteredDestCards = isSameList
          ? destCards.filter((c) => c.id !== draggableId)
          : destCards;

        const before = filteredDestCards[destination.index - 1]?.position ?? 0;
        const after =
          filteredDestCards[destination.index]?.position ?? before + 2000;
        const newPosition = (before + after) / 2;

        moveCard({
          cardId: draggableId,
          listId: destination.droppableId,
          position: newPosition,
        });
      };

    NOTE: `sortedLists` is referenced in the LIST branch. It is already declared in the
    render section below (const sortedLists = [...]).  Move the sortedLists declaration
    to ABOVE the handlers (just after the `const [isDraggingList, setIsDraggingList]`
    line) so it is in scope inside handleDragEnd:

      const sortedLists = [...(board?.lists ?? [])].sort(
        (a, b) => a.position - b.position
      );

    Then remove the duplicate `const sortedLists` declaration that currently exists in
    the render section.  The board?.lists optional chaining is needed because board may
    be undefined at hook initialisation.

    ── 5. Add onDragStart to DragDropContext ────────────────────────────────────

    Update the DragDropContext element:
      Before: <DragDropContext onDragEnd={handleDragEnd}>
      After:  <DragDropContext onDragEnd={handleDragEnd} onDragStart={handleDragStart}>

    ── 6. Wrap column area in outer Droppable + Draggable ──────────────────────

    Replace the inner content of the scrolling Box (the children between the outer Box
    sx tags) with a board-level Droppable + per-column Draggable:

    The current structure is:
      <Box sx={{ flex:1, display:'flex', ... }}>
        {sortedLists.map((list) => (
          <ListColumn key={list.id} ... />
        ))}
        <AddListForm boardId={boardId} />
      </Box>

    Replace the contents (NOT the outer Box itself — keep its sx unchanged) with:

      <Droppable droppableId="board" direction="horizontal" type="LIST">
        {(provided) => (
          <Box
            ref={provided.innerRef}
            {...provided.droppableProps}
            sx={{
              display: 'flex',
              flexDirection: 'row',
              alignItems: 'flex-start',
              gap: 2,
              // minHeight ensures the Droppable is always a valid drop target
              minHeight: 80,
            }}
          >
            {sortedLists.map((list, index) => (
              <Draggable key={list.id} draggableId={list.id} index={index}>
                {(dragProvided, dragSnapshot) => (
                  <Box
                    ref={dragProvided.innerRef}
                    {...dragProvided.draggableProps}
                    sx={{ display: 'inline-block' }}
                  >
                    <ListColumn
                      list={list}
                      boardId={boardId}
                      onDelete={deleteList}
                      onCardClick={(card) => console.log('Card clicked:', card.id)}
                      dragHandleProps={dragProvided.dragHandleProps}
                      isDragging={dragSnapshot.isDragging}
                    />
                  </Box>
                )}
              </Draggable>
            ))}

            {provided.placeholder}

            <AddListForm boardId={boardId} disabled={isDraggingList} />
          </Box>
        )}
      </Droppable>

    IMPORTANT: The outer scrolling Box (the one with flex:1, overflowX:'auto', px:2, py:2,
    custom scrollbar etc.) stays exactly as-is. Only its CHILDREN are replaced with the
    Droppable above. The outer Box's sx and all its styling props are preserved unchanged.
  </action>
  <verify>
    Grep spot-checks:
      grep "type=\"LIST\"" frontend/src/pages/BoardPage.jsx          # outer Droppable
      grep "droppableId=\"board\"" frontend/src/pages/BoardPage.jsx  # board droppable id
      grep "isDraggingList" frontend/src/pages/BoardPage.jsx         # drag state
      grep "moveList" frontend/src/pages/BoardPage.jsx               # useMoveList usage
      grep "onDragStart" frontend/src/pages/BoardPage.jsx            # DragDropContext prop
    All should return at least one match each.

    No duplicate sortedLists declaration:
      grep -c "const sortedLists" frontend/src/pages/BoardPage.jsx
    Should return exactly 1.
  </verify>
  <done>
    BoardPage imports Draggable, Droppable, useMoveList.
    sortedLists is declared once, before the handlers.
    handleDragStart sets isDraggingList=true for LIST type drags.
    handleDragEnd resets isDraggingList, handles LIST branch with rebalanced positions,
    preserves existing CARD branch logic unchanged.
    Outer Droppable (type=LIST, direction=horizontal) wraps all columns.
    Each ListColumn is wrapped in a Draggable passing dragHandleProps + isDragging.
    AddListForm receives disabled={isDraggingList}.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full list drag-and-drop wiring across all 5 files:
    - api/lists.js: FIX-01 body key fix
    - hooks/useBoardDetail.js: useMoveList with optimistic update + rollback
    - ListColumn.jsx: dragHandleProps spread on header + isDragging opacity
    - AddListForm.jsx: disabled prop
    - BoardPage.jsx: outer Droppable/Draggable, LIST/CARD dispatch in handleDragEnd
  </what-built>
  <how-to-verify>
    Start the dev stack if not already running:
      cd d:/workspace/trello-clone && docker-compose up -d

    Then open the app (typically http://localhost:5173) and test:

    1. DRAG WORKS
       - Open a board that has 2+ lists
       - Hover over a list header — cursor should change to "grab"
       - Click and hold the header, drag left or right
       - The column should move in real time with a semi-transparent drag ghost
       - Drop it in a new position — it snaps into place immediately

    2. ORDER PERSISTS ON REFRESH
       - After dropping a list in a new position, press F5 / Cmd+R
       - The board should reload showing the SAME column order

    3. OPTIMISTIC UPDATE
       - Move a list — the reorder should be instant, no spinner

    4. ROLLBACK ON API ERROR (optional — test by temporarily patching)
       - In api/lists.js temporarily change '/lists/reorder' to '/lists/BROKEN'
       - Drag a list and drop it — it should snap back to original position
       - Revert the change

    5. CARD DND REGRESSION CHECK
       - Drag a card between two lists — must still work normally
       - Drag a card within a list — must still work normally

    6. ADD LIST DISABLED DURING DRAG
       - Start dragging a list column
       - The "Add list" button should appear visually disabled while dragging
  </how-to-verify>
  <resume-signal>
    Type "approved" if all 5 main checks pass.
    Or describe any issues observed (e.g. "cards no longer drag" / "order not persisting").
  </resume-signal>
</task>

</tasks>

<verification>
All grep checks from Task 1 verify section pass.
Human verification checkpoint passes (approved).
</verification>

<success_criteria>
- LIST-04: User can drag a list column left/right to reorder it
- LIST-05: Reordered position persists after page refresh
- LIST-06: UI updates immediately, rolls back on API error
- FIX-01: reorderLists body key is `lists`
- Card DnD regression-free
</success_criteria>

<output>
After completion, create `.gsd/phases/01-enable-list-drag-and-drop/01-03-SUMMARY.md`
</output>
